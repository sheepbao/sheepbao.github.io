<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <title>boya blog</title>
  <meta property="og:title" content="boya blog" />
  <meta name="twitter:title" content="boya blog" />
  <meta name="author" content=""/>
  <link href='https://sheepbao.github.io/img/favicon.ico' rel='icon' type='image/x-icon'/>
  <meta property="og:image" content="https://sheepbao.github.io/img/favicon.ico" />
  <meta name="twitter:image" content="https://sheepbao.github.io/img/favicon.ico" />
  <meta name="twitter:card" content="summary" />
  <meta property="og:url" content="https://sheepbao.github.io/" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="boya blog" />

  <meta name="generator" content="Hugo 0.26" />
  <link rel="canonical" href="https://sheepbao.github.io/" />
  <link rel="alternate" href="https://sheepbao.github.io/index.xml" type="application/rss+xml" title="boya blog">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css" integrity="sha384-wITovz90syo1dJWVh32uuETPVEtGigN07tkttEqPv+uR2SE/mbQcG7ATL28aI9H0" crossorigin="anonymous">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" />
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <link rel="stylesheet" href="https://sheepbao.github.io/css/main.css" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" />
  <link rel="stylesheet" href="https://sheepbao.github.io/css/pygment_highlights.css" />
  <link rel="stylesheet" href="https://sheepbao.github.io/css/highlight.min.css" />


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe.min.css" integrity="sha256-sCl5PUOGMLfFYctzDW3MtRib0ctyUvI9Qsmq2wXOeBY=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/default-skin/default-skin.min.css" integrity="sha256-BFeI1V+Vh1Rk37wswuOYn5lsTcaU96hGaI7OUVCLjPc=" crossorigin="anonymous" />



<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

</head>

  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="https://sheepbao.github.io/">boya blog</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li>
              <a title="posts" href="/post/">posts</a>
            </li>
          
        
          
            <li>
              <a title="categories" href="/categories/">categories</a>
            </li>
          
        
          
            <li>
              <a title="tags" href="/tags/">tags</a>
            </li>
          
        
          
            <li>
              <a title="aboutme" href="/about/">aboutme</a>
            </li>
          
        

        

        
      </ul>
    </div>

    <div class="avatar-container">
      <div class="avatar-img-border">
        
          <a title="boya blog" href="https://sheepbao.github.io/">
            <img class="avatar-img" src="https://sheepbao.github.io/img/favicon.ico" alt="boya blog" />
          </a>
        
      </div>
    </div>

  </div>
</nav>




    
  
  
  




  

  <header class="header-section ">
    
    <div class="intro-header no-img">
      
      <div class="container">
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <div class="page-heading">
              <h1>boya blog</h1>
                
                  
                    <hr class="small">
                    <span class="page-subheading">let&#39;s do it</span>
                  
                
                
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>


    
  <div role="main" class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        

        <div class="posts-list">
          
          
            <article class="post-preview">
              <a href="https://sheepbao.github.io/post/p2p_by_non_servers/">
                <h2 class="post-title">利用DDoS模型来通信</h2>
                
              </a>

              <span class="post-meta">
  Posted on March 9, 2018
  
</span>


              <div class="post-entry">
                
                  

<h1 id="利用ddos来通信">利用DDoS来通信</h1>

<p>前两天看到一个新闻，世界上最大的同性交友网站github遭受了DDoS攻击了，最高的流量达到1.35Tbps（心疼github 10秒钟）。有别于普通的DDoS，该DDoS称为反射型DDoS攻击，也称放大型攻击，我个人认为放大型攻击毕竟形象。</p>

<p>以下想法纯属个人意见。有不同建议或补充的的欢迎emial我<a href="https://sheepbao.github.io/about/">aboutme</a></p>

<h2 id="放大型ddos攻击的原理简单解释">放大型DDoS攻击的原理简单解释</h2>

<p>一句话解释就是攻击者伪装源目标服务器IP，发送给中间人，中间人放大后发送给目标服务器。
稍微详细的讲：假设有三台服务器A、B、C，A的IP为ip1，B的IP为ip2, C的IP为ip3，A要攻击C。</p>

<pre><code>  +------+            +------+              +------+   
  |      |            |      |   ----&gt;      |      |
  |   A  |   ---&gt;     |   B  |   ----&gt;      |   C  |
  |      |            |      |   ----&gt;      |      |
  +------+            +------+              +------+
    ip1                  ip2                   ip3
</code></pre>

<p>放大型攻击的前提条件是，有个服务器会放大你的报文，并返回给你，比如这的B服务器，假设它监听UDP端口6677，且你给这个UDP端口发送消息（或者特定的消息）后会返回更多的数据给你。那么攻击者A只需要做以下事情。<br />
A发送数据给B，并更改自己的源IP为ip3，B接收到A的数据后根据源IP返回给原来的IP地址，也就是C，此时C就收到了来自A的成吨伤害，因为B将数据包放大了，原来A可能只发送了“hello”给B，而B却发送了“hello，hello，hello”给C。</p>

<h2 id="放大型ddos攻击也是一种通信模型">放大型DDoS攻击也是一种通信模型</h2>

<p>其实仔细想想，放大型DDoS攻击也是一种通信模型，这种模型将A的数据发送给了C，这模型很有意思是，我发送的源IP变成了我真正的目的IP，我在想，那么在公网上我更改ICMP报文的源IP，然后利用ICMP的payload来实现自己的协议，从而完成A到C的通信。不过这种模型有个很致命的特点，就是不能实现两个都在内网的机器通信，假设A、C都在内网，B在公网，A发送到B的数据包经过snat后，源IP都被更改为了A出口路由器的IP了。A、C一个在公网一个在内网也可以通信，不过需要知道C的mac地址，和公网IP。</p>

<h2 id="利用这种模型来选路">利用这种模型来选路？</h2>

<p>如果在有些条件下，A可以访问B，但A不能直接访问C，而B可以访问C，我又不想申请任何服务器，那么理论上可以利用这个模型来通信。
假设A在内网内，B是公网中的一些服务器。</p>

<ol>
<li>找到B服务器，B服务器的条件是，只要没有禁止ping包（当然有其他反射型的端口报文也可以）。<br /></li>
<li>需要有自己的C服务器，来接收B发送的报文并处理。</li>
<li>更改A的源IP为C的IP，发送报文即可。</li>
</ol>

<p>其实如果能找到有那么一种B服务器，能发射TCP数据包，理论上没有C也可以访问在C区域的一些公开服务。</p>

<h2 id="结论">结论</h2>

<p>以上纯属个人瞎想。</p>

                
              </div>

              
                <span class="post-meta">
                
                  #<a href="https://sheepbao.github.io/tags/idea/">Idea</a>&nbsp;
                
                </span>
              
            </article>
          
            <article class="post-preview">
              <a href="https://sheepbao.github.io/post/golang_for_range_complete_guide/">
                <h2 class="post-title">golang for语句完全指南</h2>
                
              </a>

              <span class="post-meta">
  Posted on January 13, 2018
  
</span>


              <div class="post-entry">
                
                  以下所有观点都是个人愚见，有不同建议或补充的的欢迎emialaboutme
原文章地址
关于for语句的疑问
for语句的规范
for语句的内部实现-array
问题解答
关于for语句的疑问 我们都知道在golang中，循环语句只有for这一个，在代码中写一个循环都一般都需要用到for(当然你用goto也是可以的)， 虽然golang的for语句很方便，但不少初学者一样对for语句持有不少疑问，如：
 for语句一共有多少种表达式格式？ for语句中临时变量是怎么回事？（为什么有时遍历赋值后，所有的值都等于最后一个元素） range后面支持的数据类型有哪些？ range string类型为何得到的是rune类型？ 遍历slice的时候增加或删除数据会怎么样？ 遍历map的时候增加或删除数据会怎么样？  其实这里的很多疑问都可以看golang编程语言规范, 有兴趣的同学完全可以自己看，然后根据自己的理解来解答这些问题。
for语句的规范 for语句的功能用来指定重复执行的语句块，for语句中的表达式有三种：
官方的规范： ForStmt = &quot;for&quot; [ Condition | ForClause | RangeClause ] Block .
 Condition = Expression .
 ForClause = [ InitStmt ] &ldquo;;&rdquo; [ Condition ] &ldquo;;&rdquo; [ PostStmt ] .
 RangeClause = [ ExpressionList &ldquo;=&rdquo; | IdentifierList &ldquo;:=&rdquo; ] &ldquo;range&rdquo; Expression .
  单个条件判断 形式：
                  <a href="https://sheepbao.github.io/post/golang_for_range_complete_guide/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <span class="post-meta">
                
                  #<a href="https://sheepbao.github.io/tags/go/">Go</a>&nbsp;
                
                </span>
              
            </article>
          
            <article class="post-preview">
              <a href="https://sheepbao.github.io/post/golang_list/">
                <h2 class="post-title">链表以及golang介入式链表的实现</h2>
                
              </a>

              <span class="post-meta">
  Posted on October 14, 2017
  
</span>


              <div class="post-entry">
                
                  链表以及golang介入式链表的实现 今天看tcp/ip协议栈的代码时看到一个双向链表，链表吗？听过它的顶顶大名，知道它是由节点构成的，每个节点还有个指针指向下一个节点，但是从来没自己实现过一个，没有实践就不能深刻理解，遂有此文。
以下所有观点都是个人愚见，有不同建议或补充的的欢迎emial我aboutme
何为链表？ 链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。
简单的说链表是一个具有逻辑顺序的线性表，每一个节点里存到下一个节点的指针。
图示 单链表 双向链表 链表有啥用？ 因为链表插入很快，而且具有动态性，想添加几个元素就添加几个（内存空间足够），不像数组一样那么死板，正因为链表的灵活性，所有链表的用处是大大的有啊。
链表最适合用于频繁更新变化的数据，比如一个需要异步执行并且不可丢失的命令序列、一个需要进行实时加载与卸载的驱动，无序且数量未知，这个时候就需要链表结构来协助完成数据的管理。如果不需要过度关注数据的顺序，还可以用链表方便快捷地在任意一个地方插入或删除一个元素，并且不会影响到其它的元素。
又或者我在今天看tcp/ip源码中，链表用来构造队列，作为数据段的队列。我想链表用于队列应该是最多的。如果你看过linux内核源码，应该会发现linux内核中多处使用链表这种结构。
go标准库的双向链表 golang的标准库中实现了一个双向链表，该链表可以存储任何数据，先看看使用标准库链表的例子：
package list_test import ( &quot;container/list&quot; &quot;fmt&quot; &quot;testing&quot; ) func TestList(t *testing.T) { // Create a new list and put some numbers in it. l := list.New() e4 := l.PushBack(4) e1 := l.PushFront(1) l.InsertBefore(3, e4) l.InsertAfter(2, e1) // Iterate through list and print its contents. for e := l.Front(); e != nil; e = e.
                  <a href="https://sheepbao.github.io/post/golang_list/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <span class="post-meta">
                
                  #<a href="https://sheepbao.github.io/tags/go/">Go</a>&nbsp;
                
                </span>
              
            </article>
          
            <article class="post-preview">
              <a href="https://sheepbao.github.io/post/golang_byte_slice_and_string/">
                <h2 class="post-title">golang string和[]byte的对比</h2>
                
              </a>

              <span class="post-meta">
  Posted on September 30, 2017
  
</span>


              <div class="post-entry">
                
                  golang string和[]byte的对比 为啥string和[]byte类型转换需要一定的代价？
为啥内置函数copy会有一种特殊情况copy(dst []byte, src string) int?
string和[]byte，底层都是数组，但为什么[]byte比string灵活，拼接性能也更高（动态字符串拼接性能对比）?
今天看了源码探究了一下。
以下所有观点都是个人愚见，有不同建议或补充的的欢迎emial我aboutme
何为string？ 什么是字符串？标准库builtin的解释：
type string string is the set of all strings of 8-bit bytes, conventionally but not necessarily representing UTF-8-encoded text. A string may be empty, but not nil. Values of string type are immutable.  简单的来说字符串是一系列8位字节的集合，通常但不一定代表UTF-8编码的文本。字符串可以为空，但不能为nil。而且字符串的值是不能改变的。
不同的语言字符串有不同的实现，在go的源码中src/runtime/string.go，string的定义如下：
type stringStruct struct { str unsafe.Pointer len int }  可以看到str其实是个指针，指向某个数组的首地址，另一个字段是len长度。那到这个数组是什么呢？ 在实例化这个stringStruct的时候：
func gostringnocopy(str *byte) string { ss := stringStruct{str: unsafe.
                  <a href="https://sheepbao.github.io/post/golang_byte_slice_and_string/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <span class="post-meta">
                
                  #<a href="https://sheepbao.github.io/tags/go/">Go</a>&nbsp;
                
                </span>
              
            </article>
          
            <article class="post-preview">
              <a href="https://sheepbao.github.io/post/tcp_rto_research_and_golang_implement/">
                <h2 class="post-title">TCP RTO计算方法以及go实现验证</h2>
                
              </a>

              <span class="post-meta">
  Posted on September 4, 2017
  
</span>


              <div class="post-entry">
                
                  TCP RTO计算方法和思考以及go实现验证 概述 最近在研究tcp的重传机制，tcp的重传大概有三种，超时重传(rto)、快速重传(fack)、早期重传(er)。今天讲讲rto，并用go实现其算法，探究一下。主要参考tcp/ip-guid
基本概念 RTO即超时重传时间
RTT数据包往返时间
平均偏差是指单项测定值与平均值的偏差（取绝对值）之和，除以测定次数。
RTO计算算法 RTO的计算依赖于RTT值，或者说一系列RTT值。rto=f(rtt)
在Linux中，最开始实现的是一个比较简单的经典算法RFC793，后来1988年提出了新的算法计算rto值，文档为RFC6298. 下面对比一下两种算法。
经典算法 rfc原文  An Example Retransmission Timeout Procedure Measure the elapsed time between sending a data octet with a particular sequence number and receiving an acknowledgment that covers that sequence number (segments sent do not have to match segments received). This measured elapsed time is the Round Trip Time (RTT). Next compute a Smoothed Round Trip Time (SRTT) as: SRTT = ( ALPHA * SRTT ) + ((1-ALPHA) * RTT) and based on this, compute the retransmission timeout (RTO) as: RTO = min[UBOUND,max[LBOUND,(BETA*SRTT)]] where UBOUND is an upper bound on the timeout (e.
                  <a href="https://sheepbao.github.io/post/tcp_rto_research_and_golang_implement/" class="post-read-more">[Read More]</a>
                
              </div>

              
            </article>
          
            <article class="post-preview">
              <a href="https://sheepbao.github.io/post/golang_walkthrough_io/">
                <h2 class="post-title">Golang walkthrough: io package</h2>
                
              </a>

              <span class="post-meta">
  Posted on August 28, 2017
  
</span>


              <div class="post-entry">
                
                  Golang walkthrough: io package Go是用于处理字节的编程语言。 无论您有字节列表，字节流还是单个字节，Go都可以轻松处理。 从这些简单的原语，我们构建了我们的抽象和服务。 io包是标准库中最基础的包之一。 它提供了一组用于处理字节流的接口和助手。
这篇文章是一系列演练的一部分，可以帮助您更好地了解标准库。 虽然官方的文档提供了大量的信息，但是在现实世界的环境中还是很难理解库的意思。 本系列旨在提供如何在每天应用程序中使用标准库包的上下文。 如果您有任何问题或意见，可以在Twitter上的@benbjohnson与我联系。（当然也可以联系我，listomebao@gmail.com）
Reading bytes 字节有两个最基本的操作，读和写。让我们先看如何读字节。
Reader interface 从数据流读取字节最基本的结构是Reader接口：
type Reader interface { Read(p []byte) (n int, err error) }  该接口贯穿在整个标准库中的实现，从网络连接到文件都是内存片的包装。
读取器通过将缓冲区p传递给Read()方法，以便我们可以重用相同的字节。 如果Read()返回一个字节片而不是接受一个参数，那么读者将不得不在每个Read()调用上分配一个新的字节片。 这将对垃圾收集器造成严重破坏。
Reader接口的一个问题是它附带了一些细微的规则。 首先，当流完成时，它返回一个io.EOF错误作为使用的正常部分。 这可能会让初学者感到困惑。 其次，您的缓冲区不能保证填写。 如果您传递8字节的片段，则可以在0到8个字节之间的任何地方接收。 处理部分读取可能是凌乱和容易出错的。 幸运的是有这些问题的帮助函数。
Improving reader guarantees 假设你有一个协议你正在解析，你知道你需要从阅读器读取一个8字节的uint64值。 在这种情况下，最好使用io.ReadFull()，因为你有一个固定的大小读取：
func ReadFull(r Reader, buf []byte) (n int, err error)  此功能确保您的缓冲区在返回前完全填充数据。 如果您的缓冲区部分读取，那么您将收到一个io.ErrUnexpectedEOF。 如果没有读取字节，则返回io.EOF。 这个简单的保证可以极大地简化你的代码。 要读取8个字节，您只需要这样做：
buf := make([]byte, 8) if _, err := io.
                  <a href="https://sheepbao.github.io/post/golang_walkthrough_io/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <span class="post-meta">
                
                  #<a href="https://sheepbao.github.io/tags/go/">Go</a>&nbsp;
                
                </span>
              
            </article>
          
            <article class="post-preview">
              <a href="https://sheepbao.github.io/post/virtual_network_in_linux/">
                <h2 class="post-title">Linux 中的虚拟网络-简介</h2>
                
              </a>

              <span class="post-meta">
  Posted on August 26, 2017
  
</span>


              <div class="post-entry">
                
                  Linux 中的虚拟网络-简介 引言 随着云计算的兴起，计算机的虚拟化达到了空前的热度，计算机的虚拟化加强了服务器负载的能力，更有效的利用计算机资源。
Linux中的真实网络设备 Linux的网络设备像一个双向的管道，数据从一头进，就会从另一头出，关键要看这两头是什么？真实的网络设备中，如下图的eth0，
一头是网络协议栈，另一头网卡。用户发送数据的时候经过socket api调用，进入Linux 网络协议栈处理，再进入Linux 网络设备，最后进入网卡，
如果是接收数据则反过来。
+-------------------------------------------+ | | | +-------------------+ | | | User Application | | | +-------------------+ | | | | |.................|.........................| | ↓ | | +----------+ | | | socket | | | +----------+ | | | | |.................|.........................| | ↓ | | +------------------------+ | | | Newwork Protocol Stack | | | +------------------------+ | | | | |.................|.........................| | ↓ | | +----------------+ | | | eth0 | | | +----------------+ | | 192.
                  <a href="https://sheepbao.github.io/post/virtual_network_in_linux/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <span class="post-meta">
                
                  #<a href="https://sheepbao.github.io/tags/linux/">linux</a>&nbsp;
                
                </span>
              
            </article>
          
            <article class="post-preview">
              <a href="https://sheepbao.github.io/post/golang_code_slice/">
                <h2 class="post-title">平时整理的一些golang代码片段</h2>
                
              </a>

              <span class="post-meta">
  Posted on August 22, 2017
  
</span>


              <div class="post-entry">
                
                  golang 代码片段 by boya
老司机请忽略！
 用chan实现斐波那契数列  import &quot;fmt&quot; func fibonacci(c, quit chan int) { x, y := 0, 1 for { select { case c &lt;- x: x, y = y, x+y case &lt;-quit: fmt.Println(&quot;quit&quot;) return } } } func main() { c := make(chan int) quit := make(chan int) go func() { for i := 0; i &lt; 10; i++ { fmt.Println(&lt;-c) } quit &lt;- 0 }() fibonacci(c, quit) }   字符串的简单映射  func main() { rot13 := func(r rune) rune { switch { case r &gt;= 'A' &amp;&amp; r &lt;= 'Z': return 'A' + (r-'A'+13)%26 case r &gt;= 'a' &amp;&amp; r &lt;= 'z': return 'a' + (r-'a'+13)%26 } return r } fmt.
                  <a href="https://sheepbao.github.io/post/golang_code_slice/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <span class="post-meta">
                
                  #<a href="https://sheepbao.github.io/tags/go/">Go</a>&nbsp;
                
                </span>
              
            </article>
          
            <article class="post-preview">
              <a href="https://sheepbao.github.io/post/golang_code_specification/">
                <h2 class="post-title">Golang代码规范</h2>
                
              </a>

              <span class="post-meta">
  Posted on August 2, 2017
  
</span>


              <div class="post-entry">
                
                  Golang代码规范 参考https://golang.org/doc/effective_go.html
项目目录结构规范 PROJECT_NAME ├── README.md 介绍软件及文档入口 ├── bin 编译好的二进制文件,执行./build.sh自动生成，该目录也用于程序打包 ├── build.sh 自动编译的脚本 ├── doc 该项目的文档 ├── pack 打包后的程序放在此处 ├── pack.sh 自动打包的脚本，生成类似xxxx.20170713_14:45:35.tar.gz的文件，放在pack文件下 └── src 该项目的源代码 ├── main 项目主函数 ├── model 项目代码 ├── research 在实现该项目中探究的一些程序 └── vendor 存放go的库 ├── github.com/xxx 第三方库 └── xxx.com/obc 公司内部的公共库  项目的目录结构尽量做到简明、层次清楚
文件名命名规范 用小写，尽量见名思义，看见文件名就可以知道这个文件下的大概内容，对于源代码里的文件，文件名要很好的代表了一个模块实现的功能。
命名规范 包名 包名用小写,使用短命名,尽量和标准库不要冲突
接口名 单个函数的接口名以&rdquo;er&rdquo;作为后缀，如Reader,Writer
接口的实现则去掉“er”
type Reader interface { Read(p []byte) (n int, err error) }  两个函数的接口名综合两个函数名
type WriteFlusher interface { Write([]byte) (int, error) Flush() error }  三个以上函数的接口名，类似于结构体名
                  <a href="https://sheepbao.github.io/post/golang_code_specification/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <span class="post-meta">
                
                  #<a href="https://sheepbao.github.io/tags/go/">Go</a>&nbsp;
                
                </span>
              
            </article>
          
            <article class="post-preview">
              <a href="https://sheepbao.github.io/post/golang_udp_programing/">
                <h2 class="post-title">udp编程的那些事与golang udp的实践</h2>
                
              </a>

              <span class="post-meta">
  Posted on June 19, 2017
  
</span>


              <div class="post-entry">
                
                  udp编程的那些事与golang udp的实践 tcp/ip大协议中，tcp编程大家应该比较熟，应用的场景也很多，但是udp在现实中，应用也不少，而在大部分博文中，都很少对udp的编程进行研究，最近研究了一下udp编程，正好做个记录。
sheepbao 2017.06.15
tcp Vs udp tcp和udp都是著名的传输协议，他们都是基于ip协议，都在OSI模型中传输层。tcp我们都很清楚，它提供了可靠的数据传输，而udp我们也知道，它不提供数据传输的可靠性，只是尽力传输。 他们的特性决定了它们很大的不同，tcp提供可靠性传输，有三次握手，4次分手，相当于具有逻辑上的连接，可以知道这个tcp连接的状态，所以我们都说tcp是面向连接的socket，而udp没有握手，没有分手，也不存在逻辑上的连接，所以我们也都说udp是非面向连接的socket。
我们都畏惧不知道状态的东西，所以即使tcp的协议比udp复杂很多，但对于系统应用层的编程来说，tcp编程其实比udp编程容易。而udp相对比较灵活，所以对于udp编程反而没那么容易，但其实掌握后udp编程也并不难。
udp协议 udp的首部 2 2 (byte) +---+---+---+---+---+---+---+---+ - | src port | dst port | | +---+---+---+---+---+---+---+---+ 8（bytes） | length | check sum | | +---+---+---+---+---+---+---+---+ - | | + data + | | +---+---+---+---+---+---+---+---+  udp的首部真的很简单，头2个字节表示的是原端口，后2个字节表示的是目的端口，端口是系统层区分进程的标识。接着是udp长度，最后就是校验和，这个其实很重要，现在的系统都是默认开启udp校验和的，所以我们才能确保udp消息传输的完整性。如果这个校验和关闭了，那会让我们绝对会很忧伤，因为udp不仅不能保证数据一定到达，还不能保证即使数据到了，这个数据是否是正确的。比如：我在发送端发送了“hello”，而接收端却接收到了“hell”。如果真的是这样，我们就必须自己去校验数据的正确性。还好udp默认开发了校验，我们可以保证udp的数据完整性。
udp数据的封装 +---------+ | 应用数据 | +---------+ | | v v +---------+---------+ | udp首部 | 应用数据 | +---------+---------+ | | v UDP数据报 v +---------+---------+---------+ | ip首部 | udp首部 | 应用数据 | +---------+---------+---------+ | | v IP数据报 v +---------+---------+---------+---------+---------+ |以太网首部 | ip首部 | udp首部 | 应用数据 |以太网尾部 | +---------+---------+---------+---------+---------+ | 14 20 8 4 | | -&gt; 以太网帧 &lt;- |  数据的封装和tcp是一样，应用层的数据加上udp首部，构成udp数据报，再加上ip首部构成ip数据报，最后加上以太网首部和尾部构成以太网帧，经过网卡发送出去。
                  <a href="https://sheepbao.github.io/post/golang_udp_programing/" class="post-read-more">[Read More]</a>
                
              </div>

              
                <span class="post-meta">
                
                  #<a href="https://sheepbao.github.io/tags/go/">Go</a>&nbsp;
                
                </span>
              
            </article>
          
        </div>

        
          <ul class="pager main-pager">
            
            
              <li class="next">
                <a href="/page/2">Older Posts &rarr;</a>
              </li>
            
          </ul>
        
      </div>
    </div>
  </div>

    <footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          
          
        </ul>
        <p class="credits copyright text-muted">
          
          
          &nbsp;&bull;&nbsp;
          2018

          
            &nbsp;&bull;&nbsp;
            <a href="https://sheepbao.github.io/">boya blog</a>
          
        </p>
        
        <p class="credits theme-by text-muted">
          <a href="http://gohugo.io">Hugo v0.26</a> powered &nbsp;&bull;&nbsp; Theme by <a href="http://deanattali.com/beautiful-jekyll/">Beautiful Jekyll</a> adapted to <a href="https://github.com/halogenica/beautifulhugo">Beautiful Hugo</a>
          
        </p>
      </div>
    </div>
  </div>
</footer>

<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.js" integrity="sha384-/y1Nn9+QQAipbNQWU65krzJralCnuOasHncUFXGkdwntGeSvQicrYkiUBwsgUqc1" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/contrib/auto-render.min.js" integrity="sha384-dq1/gEHSxPZQ7DdrM82ID4YVol9BYyU7GbWlIwnwyPzotpoc57wDw/guX8EaYGPx" crossorigin="anonymous"></script>
<script src="https://code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<script src="https://sheepbao.github.io/js/main.js"></script>
<script src="https://sheepbao.github.io/js/highlight.min.js"></script>
<script> hljs.initHighlightingOnLoad(); </script>
<script> renderMathInElement(document.body); </script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe.min.js" integrity="sha256-UplRCs9v4KXVJvVY+p+RSo5Q4ilAUXh7kpjyIP5odyc=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.1/photoswipe-ui-default.min.js" integrity="sha256-PWHOlUzc96pMc8ThwRIXPn8yH4NOLu42RQ0b9SpnpFk=" crossorigin="anonymous"></script>
<script src="https://sheepbao.github.io/js/load-photoswipe.js"></script>



  </body>
</html>

